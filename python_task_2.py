# -*- coding: utf-8 -*-
"""python_task_2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VuS7hJiQA7juHCmsqkHQnUqt8nsWINv9
"""

import pandas as pd

def calculate_distance_matrix(dataset):
    # Assuming dataset has columns id, toll_booth, distance
    # Assuming distance is cumulative along known routes

    # Pivot the dataset to create a distance matrix
    distance_matrix = dataset.pivot(index='id', columns='toll_booth', values='distance').fillna(0)

    # Make the matrix symmetric by adding its transpose
    distance_matrix = distance_matrix + distance_matrix.transpose()

    # Set diagonal values to 0
    distance_matrix.values[[range(distance_matrix.shape[0])]*2] = 0

    return distance_matrix

# Example usage:
# Assuming dataset-3.csv is loaded into a pandas DataFrame called df
# result_dataframe = calculate_distance_matrix(df)

import pandas as pd

def unroll_distance_matrix(distance_matrix):
    # Get the column names from the distance matrix
    columns = distance_matrix.columns

    # Create a DataFrame to store the unrolled distance matrix
    unrolled_df = pd.DataFrame(columns=['id_start', 'id_end', 'distance'])

    # Iterate through combinations of id_start and id_end
    for id_start in columns:
        for id_end in columns:
            # Skip combinations where id_start is equal to id_end
            if id_start != id_end:
                # Extract distance from the distance matrix
                distance = distance_matrix.loc[id_start, id_end]

                # Append the row to the unrolled DataFrame
                unrolled_df = unrolled_df.append({'id_start': id_start, 'id_end': id_end, 'distance': distance}, ignore_index=True)

    return unrolled_df

# Example usage:
# Assuming result_dataframe from Question 1 is the input distance matrix DataFrame
# unrolled_dataframe = unroll_distance_matrix(result_dataframe)

import pandas as pd

def find_ids_within_ten_percentage_threshold(unrolled_df, reference_value):
    # Calculate the average distance for the reference value
    reference_avg_distance = unrolled_df[unrolled_df['id_start'] == reference_value]['distance'].mean()

    # Calculate the lower and upper bounds within 10% of the average
    lower_bound = reference_avg_distance * 0.9
    upper_bound = reference_avg_distance * 1.1

    # Filter the rows that lie within the 10% threshold
    filtered_df = unrolled_df[(unrolled_df['distance'] >= lower_bound) & (unrolled_df['distance'] <= upper_bound)]

    # Get the unique values from the 'id_start' column and sort them
    result_list = sorted(filtered_df['id_start'].unique())

    return result_list

# Example usage:
# Assuming unrolled_dataframe from Question 2 is the input unrolled distance matrix DataFrame
# reference_id_value = 123  # Replace with the desired reference value
# result_list = find_ids_within_ten_percentage_threshold(unrolled_dataframe, reference_id_value)

import pandas as pd

def calculate_toll_rate(unrolled_df):
    # Define rate coefficients for each vehicle type
    rate_coefficients = {'moto': 0.8, 'car': 1.2, 'rv': 1.5, 'bus': 2.2, 'truck': 3.6}

    # Iterate through each vehicle type and calculate toll rates
    for vehicle_type, rate_coefficient in rate_coefficients.items():
        # Calculate toll rate by multiplying distance with the rate coefficient
        unrolled_df[vehicle_type] = unrolled_df['distance'] * rate_coefficient

    return unrolled_df

# Example usage:
# Assuming unrolled_dataframe from Question 2 is the input unrolled distance matrix DataFrame
# result_dataframe = calculate_toll_rate(unrolled_dataframe)

import pandas as pd
from datetime import datetime, timedelta, time

def calculate_time_based_toll_rates(unrolled_df):
    # Define time ranges and discount factors
    time_ranges = [(time(0, 0, 0), time(10, 0, 0)), (time(10, 0, 0), time(18, 0, 0)), (time(18, 0, 0), time(23, 59, 59))]
    weekday_discount_factors = [0.8, 1.2, 0.8]
    weekend_discount_factor = 0.7

    # Create a function to calculate time-based toll rates
    def calculate_toll_rate(row):
        day_of_week = row['start_day']
        start_time = row['start_time']

        # Check if it's a weekday or weekend
        if day_of_week in ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']:
            discount_factors = weekday_discount_factors
        else:  # Saturday or Sunday
            discount_factors = [weekend_discount_factor] * len(time_ranges)

        # Check the time range and apply the corresponding discount factor
        for i, (start_range, end_range) in enumerate(time_ranges):
            if start_range <= start_time <= end_range:
                return row['distance'] * discount_factors[i]

    # Apply the calculate_toll_rate function to create the time_based_toll column
    unrolled_df['time_based_toll'] = unrolled_df.apply(calculate_toll_rate, axis=1)

    return unrolled_df

# Example usage:
# Assuming unrolled_dataframe from Question 3 is the input unrolled DataFrame
# result_dataframe = calculate_time_based_toll_rates(unrolled_dataframe)